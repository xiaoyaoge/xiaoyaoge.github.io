<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小摇歌</title>
  
  <subtitle>个人工作、学习、生活的感悟及所得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoyaoge.github.io/"/>
  <updated>2019-03-26T09:18:21.519Z</updated>
  <id>https://xiaoyaoge.github.io/</id>
  
  <author>
    <name>Owen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人生</title>
    <link href="https://xiaoyaoge.github.io/spring1/"/>
    <id>https://xiaoyaoge.github.io/spring1/</id>
    <published>2019-03-18T07:30:24.000Z</published>
    <updated>2019-03-26T09:18:21.519Z</updated>
    
    <content type="html"><![CDATA[<p>一个在嘴边挂了多年的决定在2018年国庆节前突然下定决心，考驾照这件事悄然落定，加上有同事小虎一起正好有个伴，想着工作这么多年也没休过假，这次趁着考驾照的空档顺便出去走走旅旅游看看别人世界和了解一下不一样的生活方式，于是决然辞职…</p><a id="more"></a><p>世界上所有的说走就是走都是一拍即合，可所有的结果却是都是来之不易。</p><p>辞职后来到长沙一个离家近却没有家的城市，长沙相比于深圳生活节奏确实比较慢，走在长沙的街头看不到深圳那样步伐急促的人群，偶尔会有情侣牵着手有说有笑的从你身边走过，但是每到节假日长沙街头巷尾也和深圳一样满是人山人海，我想大家看到这种场面都会和我一样发一声 ’我越过高山和大海过却挤不过人山人海’感叹吧。</p><p>时间对我这样过了25岁的人来说真是眨眼就过。</p><p>本考来计划驾照一个半月到两个月拿到证，但是由于我在科二的时候挂了两次时间被延长了，而且和同事去旅游的计划了泡汤了，想来有点惭愧，但也确实印证了那句话– 计划赶不上变化。</p><p>起初考玩科目一的时候一切都很顺利，我们去了湖南有名的紫鹊界梯田景区，虽然我的家乡也有梯田，但是到了那我还是被当地的梯田给震撼到了，由于我们去的是时间是秋末，看到的秋梯田是一片荒凉，在我们住的农家小旅馆里看到一些摄影爱好者拍的各个季节的紫鹊界照片，一段这样的话，把我们的心情概括的很到位，春天去可以看万物苏醒，夏天去可以看青青禾苗，秋天去可以看金黄稻浪，冬天去可以看皑皑白雪。而我们去看到的是收割后的苍凉。</p><p>苍凉是真苍凉，但是我们看到了当地人民脸上上洋溢着的喜悦和那份丰收后的满足感就可以看得出他们在个季节辛勤劳作的场景。话说旅游就是带着愉悦的心情看着沿途的风景和人和事。这中间还有个小插曲，我们到达我们预订的旅馆后正好我们赶上老板一家在吃饭于是老板就看我们还没吃饭就叫我们一起吃了，在吃饭的时闲聊中了解到原来老板一家正在款待给他们家带来致富的恩人，这听起来想一个故事，但是确是真是发生的事。 </p><p>故事的开始是这样的，一个小剧组来到一个偏远的小山村取景，来到一户屋舍有点破旧的农户人家前讨水喝，大狗狂吠不止，吓得剧组人员不敢上前，这时一个六七岁左右面像可爱的小女孩从们后走出，制止了大狗，并对来人说道，我家大狗不咬人，且招呼大家进到院前坐下，端水给大家，剧组导演在询问和交流中发现这个小女孩吐字清除且恒友礼貌，就对这小女孩家长有些欣赏，在这样的条件下竟把子女教的这样有礼貌，于是就产生了帮助他们一家的想法，于是给小女孩一家提供了一些观念的改变和一些创业指导及为小女孩提供了一个在市重点学校上学的机会，还安排小女孩父母去学习酒店管理，于是后来就有了这家小旅馆。这些年靠着当地的自然风光和旅馆所在的独天德厚的地理优势，吸引了不少游客前来旅居和就餐日子也是越过越红火。饭后我们就在观看当年的剧组在拍摄当年那个小女孩一家的变化做一个成功脱贫致富的宣传片。 这就是人们常说的天助自助者吧。</p><p>这次旅行虽然没有赶上紫鹊界梯田春天的万物苏醒、夏天的青青禾苗、秋天的金黄稻浪、冬天的皑皑白雪但是我们感受到了生活，赶上了人间温情。</p><p>旅行归来我们就沉浸在车学和看书的氛围中，由于同事以前学过车在学车的过程中显得快快一点，于是教练就提前给他安排了科目二的考试，当得知他考过了，我也无比的开心，就期待着我开考的日子，考完好迎接我们的第二次旅行，可是事实却辜负了我们的期盼，我却在考试过程中由于太过紧张挂科了，虽然这次挂科影响了我们第二次出行的日期，于是我还是继续为科目二考试做准备，而小虎就直接在为科目三考试努力着。我在一顿煎熬中终于迎来了再次科二的考试，可这次结果又没有朝着预想中的发展，我再一次挂科了，几天后小虎科三考试，这几天我心里很是矛盾既希望他过又希望他考不过，经过顿煎熬后但他打电话给我他过考过了我的一颗心也随之放下了，但是我真心为他感到高兴。</p><p>当天我又接到我爸妈电话说家里忙，要我回家帮忙，于是想着父母身体不太好家里的做的小生意他们忙不过来，于是我就辞了这边驾校，在离家近地方报名了，重新开始，这样既可以帮家里做点事，学车也方便，只是对小虎有点惭愧…</p><p>真的有种光阴逝水的感觉，等我在老家把学车报名弄好学了一个星期的车后，大家就忙着置办年货了，浓浓的年味迎面袭来，好久没在家乡待这么长时间了，但总感觉少了些什么，对少了小时候一起万玩的伙伴，小时候做的各种捣蛋和坏事身边总有那么几个伙伴，一起开心一起玩各种的…</p><p>接着就是在外打工的乡亲陆陆续续的回家，他们见到我的第一一句话就是你的驾照拿到了没，听到这句话的时候心里各种五味杂陈，特别当他们说自己考驾照时什么什么…<br>在一片烟花爆竹声中迎来了新年的一天，大家忙着串家走户拜访亲戚，桌上满是珍馐佳肴，人们推杯换盏，不到尽兴不归，一扫过去一年的辛勤劳苦。时间这是一剂良药除去一年辛劳的配备，大家又整装出发开始新一年的忙碌…往年我也是这个时候要离家外出打工，只因要考驾照，一直脱着。可能是老家生活节奏比较慢吧，留在家的人们没有大城市里那么快节奏。</p><p>终于在我催着中教练帮我约了十天后的考试，科二科三科四一起考，接下来迎来了一个星期的艰苦的练车生涯，在练车过程中也是各种不愉快，本来跟教练说好的交完学费后三名都不用管的，但还是被要求交各种费各种费，一起学车的伙伴们也都是各种不满，耽搁了大家的时间不说以前承诺的东西一个都没实现还出了高价钱。不过到最后顺利拿到驾照了，也就三名都不说了。</p><p>这段练车考试时间的经历可以写成一部小说。有时间我会试着些一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个在嘴边挂了多年的决定在2018年国庆节前突然下定决心，考驾照这件事悄然落定，加上有同事小虎一起正好有个伴，想着工作这么多年也没休过假，这次趁着考驾照的空档顺便出去走走旅旅游看看别人世界和了解一下不一样的生活方式，于是决然辞职…&lt;/p&gt;
    
    </summary>
    
      <category term="生活经历" scheme="https://xiaoyaoge.github.io/categories/%E7%94%9F%E6%B4%BB%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="生活" scheme="https://xiaoyaoge.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>js 浮点数运算精度问题</title>
    <link href="https://xiaoyaoge.github.io/parseFloat/"/>
    <id>https://xiaoyaoge.github.io/parseFloat/</id>
    <published>2018-11-22T08:47:55.000Z</published>
    <updated>2019-03-22T09:38:13.823Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间做的一个项目在运算浮点数的时候出现精度问题，在网上找了一些方法但是大多数解决了问题，但是写的过于复杂。不过在找资料的时候发现了几个处理浮点数比较好用的类库，后面我会在文章底部把链接粘出来。</p><a id="more"></a><p>现在我来说说我遇到的问题和解决方法</p><h5 id="浮点数的运算的精度问题"><a href="#浮点数的运算的精度问题" class="headerlink" title="浮点数的运算的精度问题"></a>浮点数的运算的精度问题</h5><p>下面是一些运算式和结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法 =====================</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="number">0.7</span> + <span class="number">0.1</span> <span class="comment">// 0.7999999999999999</span></span><br><span class="line"><span class="number">0.2</span> + <span class="number">0.4</span> <span class="comment">// 0.6000000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法 =====================</span></span><br><span class="line"><span class="number">1.5</span> - <span class="number">1.2</span> <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> <span class="comment">// 0.09999999999999998</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 乘法 =====================</span></span><br><span class="line"><span class="number">7</span>*<span class="number">0.8</span> <span class="comment">// 5.6000000000000005</span></span><br><span class="line"><span class="number">19.9</span> * <span class="number">100</span> <span class="comment">// 1989.9999999999998</span></span><br><span class="line"><span class="number">19.9</span> * <span class="number">10</span> * <span class="number">10</span> <span class="comment">// 1990</span></span><br><span class="line"><span class="number">1306377.64</span> * <span class="number">100</span> <span class="comment">// 130637763.99999999</span></span><br><span class="line"><span class="number">1306377.64</span> * <span class="number">10</span> * <span class="number">10</span> <span class="comment">// 130637763.99999999</span></span><br><span class="line"><span class="number">0.7</span> * <span class="number">180</span> <span class="comment">// 125.99999999999999</span></span><br><span class="line"><span class="number">9.7</span> * <span class="number">100</span> <span class="comment">// 969.9999999999999</span></span><br><span class="line"><span class="number">39.7</span> * <span class="number">100</span> <span class="comment">// 3970.0000000000005</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 除法 =====================</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> <span class="comment">// 2.9999999999999996</span></span><br><span class="line"><span class="number">0.69</span> / <span class="number">10</span> <span class="comment">// 0.06899999999999999</span></span><br><span class="line"><span class="number">5.6</span> / <span class="number">7</span> <span class="comment">// 0.7999999999999999</span></span><br></pre></td></tr></table></figure></p><p>上面运算式运算数来的结果计算失精，然后我就去了解了一下算机原理和 JavaScript 数字类型 Number。<br>在 JavaScript 中所有的数字都是以IEEE-754标准格式表示的，而浮点数的精度问题不是JavaScript特有的，因为有些小数以二进制表示位数是无穷的。<br>例如：<br>十进制            二进制<br>0.1              0.0001 1001 1001 1001 …<br>0.2              0.0011 0011 0011 0011 …<br>0.3              0.0100 1100 1100 1100 …<br>0.4              0.0110 0110 0110 0110 …<br>0.5              0.1<br>0.6              0.1001 1001 1001 1001 …</p><p>所以比如 1.1，其程序实际上无法真正的表示 ‘1.1’，而只能做到一定程度上的准确，这是无法避免的精度丢失：1.09999999999999999</p><p>在JavaScript中问题还要复杂些，在Chrome中测试的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.9</span> == <span class="number">0.1</span>)    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.8</span> == <span class="number">0.2</span>)    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.7</span> == <span class="number">0.3</span>)    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.6</span> == <span class="number">0.4</span>)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.5</span> == <span class="number">0.5</span>)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.3</span> == <span class="number">0.7</span>)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.2</span> == <span class="number">0.8</span>)    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0</span><span class="number">-0.1</span> == <span class="number">0.9</span>)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>在前面说了 JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。该规范定义了浮点数的格式，对于64位的浮点数在内存中的表示，最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字，具体：</p><p>第0位：符号位， s 表示 ，0表示正数，1表示负数；<br>第1位到第11位：储存指数部分， e 表示 ；<br>第12位到第63位：储存小数部分（即有效数字），f 表示，如下图表示<br><img src="https://creativeflower.github.io/img/IEEE754_floating.jpg" alt="avatar"> </p><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。</p><p>前面说了这么多，那在运算过程中到底发生了什么？</p><p>比如在 JavaScript 中计算 0.1 + 0.2时，到底发生了什么<br>首先，十进制的0.1和0.2都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。<br> 十进制 —&gt; 二进制<br> 0.1   -&gt; 0.0001100110011001…(无限)<br> 0.2   -&gt; 0.0011001100110011…(无限)</p><p>IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以上面两者相加之后得到二进制为：</p><p>0.0100110011001100110011001100110011001100110011001100 </p><p>因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差。</p><p>在 Javascript 中，整数精度同样存在问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">19571992547450991</span>); <span class="comment">//=&gt; 19571992547450990</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">19571992547450991</span>===<span class="number">19571992547450992</span>); <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure></p><p>同样的原因，在 JavaScript 中 Number类型统一按浮点数处理，整数是按最大54位来算最大(2<sup>53</sup> - 1，Number.MAX_SAFE_INTEGER,9007199254740991) 和最小 (-(2<sup>53</sup> - 1)，Number.MIN_SAFE_INTEGER,-9007199254740991) 安全整数范围的。<br>所以只要超过这个范围，就会存在被舍去的精度问题。</p><p>当然这个问题并不只是在 Javascript 中才会出现，几乎所有的编程语言都采用了 IEEE-745 浮点数表示法，任何使用二进制浮点数的编程语言都会有这个问题，只不过在很多其他语言中已经封装好了方法来避免精度的问题，而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，所以精度误差的问题就显得格外突出。</p><p>那我们这么来处理这些运算产生的精度问题？<br>下面这些函数能解决运算中产生的进度问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FloatAdd</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1,r2,m;</span><br><span class="line">    <span class="keyword">try</span>&#123;r1=arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;r2=arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">    m=<span class="built_in">Math</span>.pow(<span class="number">10</span>,<span class="built_in">Math</span>.max(r1,r2));</span><br><span class="line">    <span class="keyword">return</span> (arg1*m+arg2*m)/m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//浮点数减法运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FloatSub</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1,r2,m,n;</span><br><span class="line">    <span class="keyword">try</span>&#123;r1=arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;r2=arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">    m=<span class="built_in">Math</span>.pow(<span class="number">10</span>,<span class="built_in">Math</span>.max(r1,r2));</span><br><span class="line">    <span class="comment">//动态控制精度长度</span></span><br><span class="line">    n=(r1=r2)?r1:r2;</span><br><span class="line">    <span class="keyword">return</span> ((arg1*m-arg2*m)/m).toFixed(n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//浮点数乘法运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FloatMul</span>(<span class="params">arg1,arg2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m=<span class="number">0</span>,s1=arg1.toString(),s2=arg2.toString();</span><br><span class="line">    <span class="keyword">try</span>&#123;m+=s1.split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;m+=s2.split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(s1.replace(<span class="string">"."</span>,<span class="string">""</span>))*<span class="built_in">Number</span>(s2.replace(<span class="string">"."</span>,<span class="string">""</span>))/<span class="built_in">Math</span>.pow(<span class="number">10</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//浮点数除法运算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FloatDiv</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,r1,r2;</span><br><span class="line">    <span class="keyword">try</span>&#123;t1=arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;t2=arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">    <span class="keyword">with</span>(<span class="built_in">Math</span>)&#123;</span><br><span class="line">        r1=<span class="built_in">Number</span>(arg1.toString().replace(<span class="string">"."</span>,<span class="string">""</span>));</span><br><span class="line">        r2=<span class="built_in">Number</span>(arg2.toString().replace(<span class="string">"."</span>,<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">return</span> (r1/r2)*pow(<span class="number">10</span>,t2-t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是我们在运算中每做一次预算都来调用这些函数，像下面的一个表达式：<br>假设我恒友一个很长的运算表达式，a<em>b+c/(d+e)</em>(f+h)+s+(n-y),那这样调用上面的函数就变得很麻烦<br>下面的就是上面表达式调用函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FloatAdd(FloatAdd(s,FloatAdd(FloatMul(a,b),FloatDiv(c,FloatMul(FloatAdd(d+e),FloatAdd(f+h))))),FloatSub(n-y))</span><br></pre></td></tr></table></figure></p><p>看到上面的表达式后 我脑袋都大了，而且上面的内容也只是避免了计算精度，但对与 10/3 的计算结果是 3.333333333…(无限)<br>时，我们想要降低结果的误差我们要怎么做呢？</p><p>其实我们可以用 Number.toFixed(digits) 函数，toFixed() 精度参数digits须在0与20之间<br>但是在运算后对计算结果用toFixed进行处理后精度会缩小，因为在精度缩小的过程总会自动四舍五入。<br>下面这个表达式可以解决精度<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parseFloat((数学表达式).toFixed(digits));   toFixed() 的 digits精度参数须在 0 与20 之间</span></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">1.0</span> - <span class="number">0.9</span>).toFixed(<span class="number">10</span>)) <span class="comment">// 结果为 0.1   </span></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.3</span> / <span class="number">0.1</span>).toFixed(<span class="number">10</span>)) <span class="comment">// 结果为 3  </span></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">9.7</span> * <span class="number">100</span>).toFixed(<span class="number">10</span>)) <span class="comment">// 结果为 970 </span></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">2.22</span> + <span class="number">0.1</span>).toFixed(<span class="number">10</span>)) <span class="comment">// 结果为 2.32</span></span><br></pre></td></tr></table></figure></p><p>下面的方法是我在处理这类问题的时候，基本的思路就是通过将浮点数转换成整数进行计算，然后再将整数的小数点位调整，转回正确的浮点数结果。<br>如下代码是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formatFloat = <span class="function"><span class="keyword">function</span> (<span class="params">f, digit</span>) </span>&#123;</span><br><span class="line"><span class="comment">// f 一个浮点数，digit保留几位小数</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">Math</span>.pow(<span class="number">10</span>, digit);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.round(f * m, <span class="number">10</span>) / m; </span><br><span class="line">&#125;</span><br><span class="line">formatFloat(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">1</span>) <span class="comment">// 0.3 </span></span><br><span class="line">formatFloat(<span class="number">0.3</span> - <span class="number">0.2</span>,<span class="number">1</span>) <span class="comment">//0.1</span></span><br><span class="line">formatFloat(<span class="number">0.7</span> * <span class="number">180</span>,<span class="number">1</span>) <span class="comment">//126</span></span><br><span class="line">formatFloat(<span class="number">9.7</span> * <span class="number">100</span>,<span class="number">1</span>) <span class="comment">//970</span></span><br><span class="line">formatFloat(<span class="number">39.7</span> * <span class="number">100</span>,<span class="number">1</span>) <span class="comment">//3970</span></span><br><span class="line">formatFloat(<span class="number">0.3</span> / <span class="number">0.1</span>,<span class="number">1</span>) <span class="comment">// 0.3</span></span><br><span class="line">formatFloat(<span class="number">0.69</span> / <span class="number">10</span> ,<span class="number">3</span>) <span class="comment">// 0.069</span></span><br><span class="line">formatFloat(<span class="number">5.6</span> / <span class="number">7</span>,<span class="number">1</span>) <span class="comment">// 0.8</span></span><br><span class="line">formatFloat(<span class="number">10</span>/<span class="number">3</span>,<span class="number">1</span>) <span class="comment">// 3.3</span></span><br></pre></td></tr></table></figure></p><p>然而上面的带代码能解决我们常见的精度问题，也还是存在一定的问题，例如：formatFloat(10/3,2) 得到的结果是 3.33 精度还是有所损失；<br>如果我们的基数特别大的是后 像金额基数为1亿的时候 每一个都偏差为0.001,累加起来也是特别大的 100000000* 0.001 = 100000 因此我们要办法尽量缩小结果的误差。既然误差不能消除，这时候我就得根据自己和实际情况对运算结果偏差做一个限定（保留几位小数 把误差最大限度的控制在自己可接受的范围）。</p><h5 id="插件和类库"><a href="#插件和类库" class="headerlink" title="插件和类库"></a>插件和类库</h5><p>下面是我在网上找到的一些类库</p><h6 id="Math-js"><a href="#Math-js" class="headerlink" title="Math.js"></a>Math.js</h6><p>Math.js 是专门为 JavaScript 和 Node.js 提供的一个广泛的数学库。它具有灵活的表达式解析器，支持符号计算，配有大量内置函数和常量，并提供集成解决方案来处理不同的数据类型<br>像数字，大数字(超出安全数的数字)，复数，分数，单位和矩阵。 功能强大，易于使用。</p><p>官网：<a href="http://mathjs.org/" target="_blank" rel="noopener">http://mathjs.org/</a></p><p>GitHub：<a href="https://github.com/josdejong/mathjs" target="_blank" rel="noopener">https://github.com/josdejong/mathjs</a></p><h6 id="decimal-js"><a href="#decimal-js" class="headerlink" title="decimal.js"></a>decimal.js</h6><p>为 JavaScript 提供十进制类型的任意精度数值。</p><p>官网：<a href="http://mikemcl.github.io/decimal.js/" target="_blank" rel="noopener">http://mikemcl.github.io/decimal.js/</a></p><p>GitHub：<a href="https://github.com/MikeMcl/decimal.js" target="_blank" rel="noopener">https://github.com/MikeMcl/decimal.js</a></p><h6 id="big-js"><a href="#big-js" class="headerlink" title="big.js"></a>big.js</h6><p>官网：<a href="http://mikemcl.github.io/big.js" target="_blank" rel="noopener">http://mikemcl.github.io/big.js</a></p><p>GitHub：<a href="https://github.com/MikeMcl/big.js/" target="_blank" rel="noopener">https://github.com/MikeMcl/big.js/</a></p><h5 id="JavaScript结果-格式化数字、金额、保留几位小数等"><a href="#JavaScript结果-格式化数字、金额、保留几位小数等" class="headerlink" title="JavaScript结果 格式化数字、金额、保留几位小数等"></a>JavaScript结果 格式化数字、金额、保留几位小数等</h5><p>JavaScript 格式化数字、金额、千分位、保留几位小数、舍入舍去这里我就不做探讨了，我推荐一两个类库</p><h6 id="Numeral-js"><a href="#Numeral-js" class="headerlink" title="Numeral.js"></a>Numeral.js</h6><p>一个用于格式化和操作数字的JavaScript库。数字可以被格式化为货币，百分比，时间，几个小数位数，千分位等等。 您也可以随时创建自定义格式。<br>官网及文档：<a href="http://numeraljs.com/" target="_blank" rel="noopener">http://numeraljs.com/</a><br>GitHub：<a href="https://github.com/adamwdraper/Numeral-js" target="_blank" rel="noopener">https://github.com/adamwdraper/Numeral-js</a></p><h6 id="accounting-js"><a href="#accounting-js" class="headerlink" title="accounting.js"></a>accounting.js</h6><p>一个轻量级的JavaScript库，用于格式化数字，金额和货币等。<br>官网及文档：<a href="http://openexchangerates.github.io/accounting.js/" target="_blank" rel="noopener">http://openexchangerates.github.io/accounting.js/</a><br>GitHub：<a href="https://github.com/openexchangerates/accounting.js" target="_blank" rel="noopener">accounting.js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做的一个项目在运算浮点数的时候出现精度问题，在网上找了一些方法但是大多数解决了问题，但是写的过于复杂。不过在找资料的时候发现了几个处理浮点数比较好用的类库，后面我会在文章底部把链接粘出来。&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数 f(x) —— 构造函数及作用域与命名空间</title>
    <link href="https://xiaoyaoge.github.io/Function2/"/>
    <id>https://xiaoyaoge.github.io/Function2/</id>
    <published>2018-10-24T09:07:23.000Z</published>
    <updated>2018-10-25T12:14:58.380Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章继续学习JavaScript函数，函数在JavaScript中的地位是一等公民，所以掌握JavaScript函数是非常有必要的。</p><a id="more"></a><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过 new 关键字方式调用的函数都被认为是构造函数。</p><p>在构造函数内部 - 也就是被调用的函数内 - this 指向新创建的对象 Object。 这个新创建的对象的 prototype 被指向到构造函数的 prototype。</p><p>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 - 也就是新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bla = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.bla);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>上面代码把 Foo 作为构造函数调用，并设置新创建对象的 prototype 为 Foo.prototype。</p><p>显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar(); <span class="comment">// 返回新创建的对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Test(); <span class="comment">// 返回的对象</span></span><br></pre></td></tr></table></figure></p><p>译者注：new Bar() 返回的是新创建的对象，而不是数字的字面值 2。 因此 new Bar().constructor === Bar，但是如果返回的是数字对象，结果就不同了，如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span></span><br></pre></td></tr></table></figure></p><p>译者注：这里得到的 new Test()是函数返回的对象，而不是通过new关键字新创建的对象，因此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Test()).value === <span class="literal">undefined</span></span><br><span class="line">(<span class="keyword">new</span> Test()).foo === <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>如果 new 被遗漏了，则函数不会返回新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bla = <span class="number">1</span>; <span class="comment">// 获取设置全局参数</span></span><br><span class="line">&#125;</span><br><span class="line">Foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 this 的工作原理， 这里的 this 指向全局对象。</p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>为了不使用 new 关键字，构造函数必须显式的返回一个值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar();</span><br><span class="line">Bar();</span><br></pre></td></tr></table></figure></p><p>上面两种对 Bar 函数的调用返回的值完全相同，一个新创建的拥有 method 属性的对象被返回， 其实这里创建了一个闭包。</p><p>还需要注意， new Bar() 并不会改变返回对象的原型（译者注：也就是返回对象的原型不会指向 Bar.prototype）。 因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 Bar 没有把这个新对象返回（译者注：而是返回了一个包含 method 属性的自定义对象）。</p><p>在上面的例子中，使用或者不使用 new 关键字没有功能性的区别。</p><p>译者注：上面两种方式创建的对象不能访问 Bar 原型链上的属性，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar1 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">typeof</span>(bar1.method); <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span>(bar1.foo); <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar2 = Bar();</span><br><span class="line"><span class="keyword">typeof</span>(bar2.method); <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span>(bar2.foo); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></p><h5 id="通过工厂模式创建新对象"><a href="#通过工厂模式创建新对象" class="headerlink" title="通过工厂模式创建新对象"></a>通过工厂模式创建新对象</h5><p>我们常听到的一条忠告是不要使用 new 关键字来调用函数，因为如果忘记使用它就会导致错误。</p><p>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.value = <span class="string">'blub'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> private = <span class="number">2</span>;</span><br><span class="line">    obj.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> private;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然上面的方式比起 new 的调用方式不容易出错，并且可以充分利用私有变量带来的便利， 但是随之而来的是一些不好的地方。<br>1.会占用更多的内存，因为新创建的对象不能共享原型上的方法。<br>2.为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。<br>3.放弃原型链仅仅是因为防止遗漏 new 带来的问题，这似乎和语言本身的思想相违背。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虽然遗漏 new 关键字可能会导致问题，但这并不是放弃使用原型链的借口。 最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并坚持下去才是最重要的。</p><h4 id="作用域与命名空间"><a href="#作用域与命名空间" class="headerlink" title="作用域与命名空间"></a>作用域与命名空间</h4><p>尽管 JavaScript 支持一对花括号创建的代码段，但是并不支持块级作用域； 而仅仅支持 函数作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 一个作用域</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 不是一个作用域</span></span><br><span class="line">        <span class="comment">// count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>译者注：如果 return 对象的左括号和 return 不在一行上就会出错。<br>注意: 如果不是在赋值语句中，而是在 return 表达式或者函数参数中，{…} 将会作为代码段解析， 而不是作为对象的字面语法解析。如果考虑到 自动分号插入，这可能会导致一些不易察觉的错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：下面输出 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p><p>JavaScript 中没有显式的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。</p><p>每次引用一个变量，JavaScript 会向上遍历整个作用域直到找到这个变量为止。 如果到达全局作用域但是这个变量仍未找到，则会抛出 ReferenceError 异常。</p><h5 id="隐式的全局变量"><a href="#隐式的全局变量" class="headerlink" title="隐式的全局变量"></a>隐式的全局变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本 A</span></span><br><span class="line">foo = <span class="string">'42'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本 B</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'42'</span></span><br></pre></td></tr></table></figure><p>上面两段脚本效果不同。脚本 A 在全局作用域内定义了变量 foo，而脚本 B 在当前作用域内定义变量 foo。<br>再次强调，上面的效果完全不同，不使用 var 声明变量将会导致隐式的全局变量产生。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></p><p>在函数 test 内不使用 var 关键字声明 foo 变量将会覆盖外部的同名变量。 起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 var 声明变量将会带来难以跟踪的 BUG。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> items = [<span class="comment">/* 数组 */</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    subLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// subLoop 函数作用域</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 没有使用 var 声明变量</span></span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部循环在第一次调用 subLoop 之后就会终止，因为 subLoop 覆盖了全局变量 i。 在第二个 for 循环中使用 var 声明变量可以避免这种错误。 声明变量时绝对不要遗漏 var 关键字，除非这就是期望的影响外部作用域的行为。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>JavaScript 中局部变量只可能通过两种方式声明，一个是作为函数参数，另一个是通过 var 关键字声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数 test 内的局部作用域</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line">    bar = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>foo 和 i 是函数 test 内的局部变量，而对 bar 的赋值将会覆盖全局作用域内的同名变量。</p><h5 id="变量声明提升（Hoisting）"><a href="#变量声明提升（Hoisting）" class="headerlink" title="变量声明提升（Hoisting）"></a>变量声明提升（Hoisting）</h5><p>JavaScript 会提升变量声明。这意味着 var 表达式和 function 声明都将会被提升到当前作用域的顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bar();</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> someValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        goo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> goo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> e = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码在运行之前将会被转化。JavaScript 将会把 var 表达式和 function 声明提升到当前作用域的顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 表达式被移动到这里</span></span><br><span class="line"><span class="keyword">var</span> bar, someValue; <span class="comment">// 缺省值是 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明也会提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> goo, i, e; <span class="comment">// 没有块级作用域，这些变量被移动到函数顶部</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        goo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        goo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        e = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 出错：TypeError，因为 bar 依然是 'undefined'</span></span><br><span class="line">someValue = <span class="number">42</span>; <span class="comment">// 赋值语句不会被提升规则（hoisting）影响</span></span><br><span class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p><p>没有块级作用域不仅导致 var 表达式被从循环内移到外部，而且使一些 if 表达式更难看懂。</p><p>在原来代码中，if 表达式看起来修改了全局变量 goo，实际上在提升规则被应用后，却是在修改局部变量。</p><p>如果没有提升规则（hoisting）的知识，下面的代码看起来会抛出异常 ReferenceError。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 SomeImportantThing 是否已经被初始化</span></span><br><span class="line"><span class="keyword">if</span> (!SomeImportantThing) &#123;</span><br><span class="line">    <span class="keyword">var</span> SomeImportantThing = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，上面的代码正常运行，因为 var 表达式会被提升到全局作用域的顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SomeImportantThing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它一些代码，可能会初始化 SomeImportantThing，也可能不会</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已经被初始化</span></span><br><span class="line"><span class="keyword">if</span> (!SomeImportantThing) &#123;</span><br><span class="line">    SomeImportantThing = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>译者注：在 Nettuts+ 网站有一篇介绍 hoisting 的文章，其中的代码很有启发性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：来自 Nettuts+ 的一段代码，生动的阐述了 JavaScript 中变量声明提升规则</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="string">'my value'</span>;  </span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    alert(myvar); <span class="comment">// undefined  </span></span><br><span class="line">    <span class="keyword">var</span> myvar = <span class="string">'local value'</span>;  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h5 id="名称解析顺序"><a href="#名称解析顺序" class="headerlink" title="名称解析顺序"></a>名称解析顺序</h5><p>JavaScript 中的所有作用域，包括全局作用域，都有一个特别的名称 this 指向当前对象。</p><p>函数作用域内也有默认的变量 arguments，其中包含了传递到函数中的参数。</p><p>比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：</p><p>当前作用域内是否有 var foo 的定义。<br>函数形式参数是否有使用 foo 名称的。<br>函数自身是否叫做 foo。<br>回溯到上一级作用域，然后从 #1 重新开始。</p><p>注意: 自定义 arguments 参数将会阻止原生的 arguments 对象的创建。</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript中，这可以通过 匿名包装器 轻松解决。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数创建一个命名空间</span></span><br><span class="line">    <span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对外公开的函数，创建了闭包</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(); <span class="comment">// 立即执行此匿名函数</span></span><br></pre></td></tr></table></figure></p><p>匿名函数被认为是 表达式；因此为了可调用性，它们首先会被执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( <span class="comment">// 小括号内的函数首先被执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">) <span class="comment">// 并且返回函数对象</span></span><br><span class="line">() <span class="comment">// 调用上面的执行结果，也就是函数对象</span></span><br></pre></td></tr></table></figure></p><p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外两种方式</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure></p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>推荐使用匿名包装器（译者注：也就是自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突， 而且有利于程序的模块化。</p><p>另外，使用全局变量被认为是不好的习惯。这样的代码容易产生错误并且维护成本较高。</p><p>这篇学习闭包和作用域的学习笔记就到这了，这个里只是初学闭包和作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇文章继续学习JavaScript函数，函数在JavaScript中的地位是一等公民，所以掌握JavaScript函数是非常有必要的。&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数 f(x)</title>
    <link href="https://xiaoyaoge.github.io/Function/"/>
    <id>https://xiaoyaoge.github.io/Function/</id>
    <published>2018-10-17T08:45:23.000Z</published>
    <updated>2018-10-17T14:02:23.587Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我学习了对象 这篇文章大家和我一起来学习函，其实函数也是一个对象</p><a id="more"></a><h4 id="函数的声明与表达式"><a href="#函数的声明与表达式" class="headerlink" title="函数的声明与表达式"></a>函数的声明与表达式</h4><p>函数是JavaScript中的一等对象，这意味着可以把函数想起它值一样传递。一个常见的用法是把匿名函数作为毁掉函数传递到异步函数中</p><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的方法会在执行前被解析，因此它存在在与当前文档的任意一个地方，即使在函数在定义体的上方被调用也是对的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fun() <span class="comment">// 正常运行，因为foo在代码运行前已经被创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="函数赋值表达式"><a href="#函数赋值表达式" class="headerlink" title="函数赋值表达式"></a>函数赋值表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fun =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//  这个是把一个匿名函数赋值给变量 Fun</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面由于 var 定义了一个声明语句，对变量 foo 的解析是在代码运行之前， 因此 foo 变量在代码运行时已经被定义过了  </span></span><br><span class="line">foo; <span class="comment">// 'undefined'</span></span><br><span class="line">foo(); <span class="comment">// 出错：TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 但是由于赋值语句只在运行时执行，因此在相应代码执行之前，foo 的值缺省为 undefined。</span></span><br></pre></td></tr></table></figure><h5 id="命名函数的赋值表达式"><a href="#命名函数的赋值表达式" class="headerlink" title="命名函数的赋值表达式"></a>命名函数的赋值表达式</h5><p>有一个特殊的情况，就是将命名函数赋值给一个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">bar() <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br><span class="line">bar() <span class="comment">// 出错：ReferenceError</span></span><br><span class="line">bar 函数声明外是不可见的，是应为我们把函数赋值给了 Foo；然而在 bar 内部依然可见。这是由于 JavaScript的命名处理所导致，函数名在函数内总是可见的。</span><br></pre></td></tr></table></figure></p><p>注意:在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析， 解析成两个函数 foo 和 bar</p><h4 id="this的工作原理"><a href="#this的工作原理" class="headerlink" title="this的工作原理"></a>this的工作原理</h4><p>在大家时间工作中大家经常会弄错 this的范围，现在我们来了解一下this的工作原理</p><p>JavaScript 有一套完全不同于其他语言的对 this 的处理机制。在五中不同的情况下，this 指向的各不相同 (ES6 的尖括号函数解放了this ）</p><h5 id="全局范围内的-this"><a href="#全局范围内的-this" class="headerlink" title="全局范围内的 this"></a>全局范围内的 this</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>； <span class="comment">// 当在全部范围内使用 this，它将会指向全局对象。</span></span><br></pre></td></tr></table></figure><p>当在全部范围内使用 this，它将会指向全局对象。</p><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 这里 this 也会指向全局对象。</span></span><br></pre></td></tr></table></figure><h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.foo(); <span class="comment">// 这个例子中，this 指向 test 对象。</span></span><br></pre></td></tr></table></figure><h5 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> foo();  <span class="comment">// 如果函数倾向于和 new 关键词一块使用，则我们称这个函数是构造函数。 在函数内部，this 指向新创建的对象。</span></span><br></pre></td></tr></table></figure><h5 id="调用构造函数-1"><a href="#调用构造函数-1" class="headerlink" title="调用构造函数"></a>调用构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">foo.apply(bar, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 数组将会被扩展，如下所示</span></span><br><span class="line">foo.call(bar, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传递到foo的参数是：a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure><p>当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被显式设置为函数调用的第一个参数。</p><p>因此函数调用的规则在上例中已经不适用了，在foo 函数内 this 被设置成了 bar。</p><p>注意: 在对象的字面声明语法中，this 不能用来指向对象本身。 因此 var obj = {me: this} 中的 me 不会指向 obj，因为 this 只可能出现在上述的五种情况中。 译者注：这个例子中，如果是在浏览器中运行， obj.me 等于 window 对象。</p><h5 id="常见误解"><a href="#常见误解" class="headerlink" title="常见误解"></a>常见误解</h5><p>尽管大部分的情况都说的过去，不过第一个规则（译者注：这里指的应该是第二个规则，也就是直接调用函数时，this 指向全局对象） 被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个常见的误解是 test 中的 this 将会指向 Foo 对象，实际上不是这样子的。<br>为了在 test 中获取对 Foo 对象的引用，我们需要在 method 函数内部创建一个局部变量指向 Foo 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 that 来指向 Foo 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>that 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 this 对象。 在 闭包 一节，我们可以看到 that 可以作为参数传递。</p><h5 id="方法的赋值表达式"><a href="#方法的赋值表达式" class="headerlink" title="方法的赋值表达式"></a>方法的赋值表达式</h5><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = someObject.methodTest;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p><p>上例中，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。<br>然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Foo'</span>,<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Foo.prototype.method'</span>,<span class="keyword">this</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bar'</span>,<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar().method();</span><br></pre></td></tr></table></figure></p><p>当 method 被调用时，this 将会指向 Bar 的实例对象。</p><h4 id="闭包和引用"><a href="#闭包和引用" class="headerlink" title="闭包和引用"></a>闭包和引用</h4><p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为函数是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p><h5 id="模拟私有变量"><a href="#模拟私有变量" class="headerlink" title="模拟私有变量"></a>模拟私有变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = start;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = Counter(<span class="number">4</span>);</span><br><span class="line">foo.increment();</span><br><span class="line">foo.get(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这里，Counter 函数返回两个闭包，函数 increment 和函数 get。 这两个函数都维持着 对外部作用域 Counter 的引用，因此总可以访问此作用域内定义的变量 count。</p><h5 id="为什么不可以在外部访问私有变量"><a href="#为什么不可以在外部访问私有变量" class="headerlink" title="为什么不可以在外部访问私有变量"></a>为什么不可以在外部访问私有变量</h5><p>因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 count 变量。 唯一的途径就是通过那两个闭包。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Counter(<span class="number">4</span>);</span><br><span class="line">foo.hack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--- 上 ---'</span>,count)</span><br><span class="line">count = <span class="number">1337</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--- xiao ---'</span>,count)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的代码不会改变定义在 Counter 作用域中的 count 变量的值，因为 foo.hack 没有 定义在那个作用域内。它将会创建或者覆盖全局变量 count。</p><h5 id="循环中的闭包"><a href="#循环中的闭包" class="headerlink" title="循环中的闭包"></a>循环中的闭包</h5><p>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'--- 1111 ---'</span>,i);  </span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。<br>当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10.<br>为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。</p><h5 id="避免引用错误"><a href="#避免引用错误" class="headerlink" title="避免引用错误"></a>避免引用错误</h5><p>为了正确的获得循环序号，最好使用 匿名包装器（译者注：其实就是我们通常说的自执行匿名函数）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e);  </span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。</p><p>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p><p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样</p><h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p>JavaScript 中每个函数内都能访问一个特别变量 arguments。这个变量维护着所有传递到这个函数中的参数列表。<br>arguments 变量不是一个数组（Array）。 尽管在语法上它有数组相关的属性 length，但它不从 Array.prototype 继承，实际上它是一个对象（Object）。<br>注意: 由于 arguments 已经被定义为函数内的一个变量。 因此通过 var 关键字定义 arguments 或者将 arguments 声明为一个形式参数， 都将导致原生的 arguments 不会被创建。</p><p>因此，无法对 arguments 变量使用标准的数组方法，比如 push, pop 或者 slice。 虽然使用 for 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p><h5 id="转化为数组"><a href="#转化为数组" class="headerlink" title="转化为数组"></a>转化为数组</h5><p>下面的代码将会创建一个新的数组，包含所有 arguments 对象中的元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 这个转化比较慢，在性能不好的代码中不推荐这种做法</span></span><br></pre></td></tr></table></figure></p><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>下面是将参数从一个函数传递到另一个函数的推荐做法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一个技巧是同时使用 call 和 apply，创建一个快速的解绑定包装器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个解绑定的 "method"</span></span><br><span class="line"><span class="comment">// 输入参数为: this, arg1, arg2...argN</span></span><br><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果: Foo.prototype.method.call(this, arg1, arg2... argN)</span></span><br><span class="line">    <span class="built_in">Function</span>.call.apply(Foo.prototype.method, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>译者注：上面的 Foo.method 函数和下面代码的效果是一样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    Foo.prototype.method.apply(args[<span class="number">0</span>], args.slice(<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h5><p>arguments 对象为其内部属性以及函数形式参数创建 getter 和 setter 方法。</p><p>因此，改变形参的值会影响到 arguments 对象的值，反之亦然。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    a; <span class="comment">// 2                                                           </span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>]; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = c;</span><br><span class="line">    d = <span class="number">9</span>;</span><br><span class="line">    c; <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><h5 id="性能真相"><a href="#性能真相" class="headerlink" title="性能真相"></a>性能真相</h5><p>不管它是否有被使用，arguments 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。<br>arguments 的 getters 和 setters 方法总会被创建；因此使用 arguments 对性能不会有什么影响。 除非是需要对 arguments 对象的属性进行多次访问。</p><p>ES5 提示: 这些 getters 和 setters 在严格模式下（strict mode）不会被创建。</p><p>译者注：在 MDC 中对 strict mode 模式下 arguments 的描述有助于我们的理解，请看下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阐述在 ES5 的严格模式下 `arguments` 的特性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  a = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair = f(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">0</span>] === <span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">1</span>] === <span class="number">17</span>);</span><br></pre></td></tr></table></figure></p><p>然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 arguments.callee。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>.callee; <span class="comment">// do something with this function object</span></span><br><span class="line">    <span class="built_in">arguments</span>.callee.caller; <span class="comment">// and the calling function object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        foo(); <span class="comment">// Would normally be inlined...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，foo 不再是一个单纯的内联函数 inlining（译者注：这里指的是解析器可以做内联处理）， 因为它需要知道它自己和它的调用者。 这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。<br>因此强烈建议大家不要使用 arguments.callee 和它的属性。</p><p>ps: 这篇文章学到函数的 arguments 对象，下篇文章我，会写一下我学函数的 构造函数，及函数的作用域与命名空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我学习了对象 这篇文章大家和我一起来学习函，其实函数也是一个对象&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>verify-msg-code 说明文档</title>
    <link href="https://xiaoyaoge.github.io/msgCode/"/>
    <id>https://xiaoyaoge.github.io/msgCode/</id>
    <published>2018-10-16T05:25:56.000Z</published>
    <updated>2018-11-23T13:46:40.760Z</updated>
    
    <content type="html"><![CDATA[<h4 id="verify-msg-code"><a href="#verify-msg-code" class="headerlink" title="verify-msg-code"></a>verify-msg-code</h4><p>verify-msg-code 是基于 verify-input-code 插件开发的升级版<br>由于前端一直没时间维护 verify-input-code 所以决定将其废弃<br>verify-msg-code 是基于 Vue2.5+的移动端验证码输入组件.<br><a id="more"></a></p><h4 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h4><ul><li>输入时回调</li><li>结果回调</li><li>自定义错误处理</li><li>自定义验证码个数</li><li>样式可控</li><li>输入身份证验证</li><li>可以清空输入的验证码</li></ul><h4 id="基于"><a href="#基于" class="headerlink" title="基于"></a>基于</h4><p>基于 Vue.js 2.5+.</p><h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i verify-msg-code --save</span><br></pre></td></tr></table></figure><ul><li>作为全局组件使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在项目入口文件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VerifyMsgCode <span class="keyword">from</span> <span class="string">'verify-msg-code'</span></span><br><span class="line">Vue.component(<span class="string">'verifyMsgCode'</span>, VerifyMsgCode)</span><br></pre></td></tr></table></figure><ul><li>作为局部组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个组件中</span></span><br><span class="line"><span class="keyword">import</span> VerifyMsgCode <span class="keyword">from</span> <span class="string">'verify-msg-code'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    VerifyMsgCode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p> <img src="https://creativeflower.github.io/img/msgCode.png" alt="avatar"> </p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>   <a href="https://creativeflower.github.io/msgcode/" target="_blank" rel="noopener">dome地址</a><br>   <a href="https://github.com/xiaoyaoge/verify-msg-code" target="_blank" rel="noopener">github</a></p><h4 id="插件-API"><a href="#插件-API" class="headerlink" title="插件 API"></a>插件 API</h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>code</td><td>数组</td><td>用户输入的验证码数组</td><td>—</td><td>—</td></tr><tr><td>initInput</td><td>函数</td><td>给父组件调用初始化输入框</td><td>—</td><td>-</td></tr><tr><td>type</td><td>字符串</td><td>用户输入类型 当 type 为 idcard 时 number 值为 18</td><td>number,text,idcard</td><td>number</td></tr><tr><td>upper-case</td><td>Boolean</td><td>类型为 text 的时候可调整输入的字符串为大写</td><td>true,false</td><td>false</td></tr><tr><td>get-input</td><td>函数</td><td>用户每次输入后的回调函数,接受一个验证码字符串</td><td>—</td><td>—</td></tr><tr><td>success</td><td>函数</td><td>用户输入完成后的回调函数,接受一个验证码字符串</td><td>—</td><td>—</td></tr><tr><td>error</td><td>函数</td><td>用户输入不是预期的值的回调函数,接收一个错误的值,若返回 true 则不清除错误值并继续下一个输入,默认返回 false</td><td>—</td><td>—</td></tr><tr><td>span-size</td><td>字符串</td><td>输入后的字体显示大小</td><td>—</td><td>20px</td></tr><tr><td>span-color</td><td>字符串</td><td>输入后的字体显示颜色</td><td>—</td><td>#f35252</td></tr><tr><td>input-size</td><td>字符串</td><td>输入框的字体显示大小</td><td>—</td><td>20px</td></tr><tr><td>input-color</td><td>字符串</td><td>输入框的字体显示颜色</td><td>—</td><td>#000</td></tr><tr><td>number</td><td>数字</td><td>验证码个数</td><td>—</td><td>6</td></tr><tr><td>height</td><td>字符串</td><td>整个框的显示高度</td><td>—</td><td>60px</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;verify-msg-code&quot;&gt;&lt;a href=&quot;#verify-msg-code&quot; class=&quot;headerlink&quot; title=&quot;verify-msg-code&quot;&gt;&lt;/a&gt;verify-msg-code&lt;/h4&gt;&lt;p&gt;verify-msg-code 是基于 verify-input-code 插件开发的升级版&lt;br&gt;由于前端一直没时间维护 verify-input-code 所以决定将其废弃&lt;br&gt;verify-msg-code 是基于 Vue2.5+的移动端验证码输入组件.&lt;br&gt;
    
    </summary>
    
      <category term="vue插件" scheme="https://xiaoyaoge.github.io/categories/vue%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
      <category term="vue插件" scheme="https://xiaoyaoge.github.io/tags/vue%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象</title>
    <link href="https://xiaoyaoge.github.io/object/"/>
    <id>https://xiaoyaoge.github.io/object/</id>
    <published>2018-10-15T05:25:24.000Z</published>
    <updated>2018-10-17T12:48:41.787Z</updated>
    
    <content type="html"><![CDATA[<p>文章以一句 ‘回首往事，不因虚度年华而悔恨，也不因碌碌无为而羞耻’ 开头送给自己也送给各位…</p><h3 id="对象的使用和属性"><a href="#对象的使用和属性" class="headerlink" title="对象的使用和属性"></a>对象的使用和属性</h3><p>javascript中所有的变量都可以当成对象来使用，但是有两个除外，null 和 undefined。<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>.toString(); <span class="comment">// 'false'</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString(); <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="string">'123'</span>.length; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Foo.bar = <span class="number">1</span>;</span><br><span class="line">Foo.bar; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>大家常常误解数字的字面值（literal）不能当做是对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString(); <span class="comment">// 出错：SyntaxError</span></span><br></pre></td></tr></table></figure><p>其实有很多的方法可以让数字的字面量看起来像对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// "2" 第二个点号可以解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// "2"  点前面有个空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// "2" 括号中的的数字会被先计算</span></span><br><span class="line">(<span class="number">2</span>+<span class="number">1</span>).toString(); <span class="comment">// "3" 括号中的的数字会被先计算</span></span><br></pre></td></tr></table></figure></p><h5 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h5><p>JavaScript的对象可以作为<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表</a>使用,只要是用来保存命名的键与值的对应关系。</p><p>使用对象的字面语法 - {} - 可以创建一个简单的对象。这个新建的对象从Object.prototype 继承下面，没有任何自定义属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = &#123;&#125; <span class="comment">// 空对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cat = &#123; <span class="attr">name</span>:<span class="string">'小黑'</span>&#125; <span class="comment">// 一个新对象 拥有一个值为小黑的自定义属性 'name'</span></span><br></pre></td></tr></table></figure></p><h5 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h5><p>javascrippt 对象有两种方式来访问属性，点操作符和中括号操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = &#123; <span class="attr">name</span>: <span class="string">'小黑'</span>&#125;</span><br><span class="line">Dog.name <span class="comment">// 小黑</span></span><br><span class="line">Dog[<span class="string">'name'</span>] <span class="comment">// 小黑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="string">'name'</span></span><br><span class="line">Dog[getName] <span class="comment">// 小黑</span></span><br><span class="line">Dog<span class="number">.123</span> <span class="comment">//  会 SyntaxError</span></span><br><span class="line">Dog[<span class="string">'1234'</span>] <span class="comment">// 可以正常执行</span></span><br></pre></td></tr></table></figure></p><p>这两种语法是等价的，但是中括号操作符在下面两种情况下依然有效<br>1.动态设置属性<br>2.属性名不是一个有效的变量名。（注意点：比如属性名中包含空格，或者属性名是 JS 的关键词 在 JSLint 语法检测工具中，点操作符是推荐做法）</p><h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><p>删除属性唯一的方法是使用 delete 操作符，将对象属性设置为undefined或者null都不能真正删除属性，而仅仅是移除了属性和值的关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">bor: <span class="number">1</span>,</span><br><span class="line">foo: <span class="number">2</span>,</span><br><span class="line">baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.bor = <span class="literal">undefined</span>;</span><br><span class="line">obj.foo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.baz</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj )&#123;</span><br><span class="line"><span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i, <span class="string">' --&gt; '</span> + obj[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出的结果</span></span><br><span class="line">bor --&gt; <span class="literal">undefined</span></span><br><span class="line">foo --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>从上面输出的结果看，只有 baz 被真正的删除，所以就没有出现在输出结果中</p><h5 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"><span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span></span><br><span class="line"><span class="keyword">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的属性名可以使用字符串或普通字符声明。但是由于JavaScript解释器的另一个错误设计，上面的的第二种声明方式在ECMAScript5 之前会抛出 SyntaxError 的错误<br>这个错误的原因是 delete 是 JavaScript 语言的一个关键词；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用字符串字面值声明方式。</p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>JavaScript不包含传统的类继承模型，而是使用porttype原型模型。<br>虽然这经常被当做是JavaScript的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大，实现传统的类继承模很简单，但是实现JavaScript中的原型继承则要困难的多 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p><p>传统类继承和JavaScript原型继承的差异</p><p>第一个不同这出在于 JavaScript使用的是原型链的继承方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Bar的prototype属性为Foo的实例对象</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line">Bar.prototype.foo = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正Bar.prototype.constructor为Bar本身</span></span><br><span class="line">Bar.prototype.constructor = Bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Bar() <span class="comment">// 创建Bar的一个新实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">test [Bar的实例]</span><br><span class="line">    Bar.prototype [Foo的实例] </span><br><span class="line">        &#123; <span class="attr">foo</span>: <span class="string">'Hello World'</span> &#125;</span><br><span class="line">        Foo.prototype</span><br><span class="line">            &#123;<span class="attr">method</span>: ...&#125;;</span><br><span class="line">            <span class="built_in">Object</span>.prototype</span><br><span class="line">                &#123;<span class="attr">toString</span>: ... <span class="comment">/* etc. */</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的例子中，test 对象从 Bar.prototype 和Foo。prototype 继承下来；因此，它能访问 Foo 的原型方法 method。同时，他也能够访问那个定义在原型上的 Foo 实例属性 value。 需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是重复使用它原型上的那个实例； 因此，所有的 Bar 实例都会共享相同的 value 属性。<br>注意: 简单的使用 Bar.prototype = Foo.prototype 将会导致两个对象共享相同的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p><h5 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h5><p>当查找一个对象的属性是，JavaScript 会向上遍历原型链，知道找到给定名称的属性为止。</p><p>到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定属性，就会返回 undefined</p><h5 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h5><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="number">1</span>; <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure></p><p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p><p>并且，当使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问。</p><h5 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h5><p>一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。</p><p>这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。</p><p>扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如 Array.forEach。</p><p>注意：这是编程领域常用的一种方式，称之为 Backport，也就是将新的补丁添加到老版本中。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p><h4 id="hasOwnProperty-函数"><a href="#hasOwnProperty-函数" class="headerlink" title="hasOwnProperty 函数"></a>hasOwnProperty 函数</h4><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 Object.prototype 的 hasOwnProperty 方法。</p><p>注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 undefined。</p><p>hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">goo</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar; <span class="comment">// 1</span></span><br><span class="line"><span class="string">'bar'</span> <span class="keyword">in</span> foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// false</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'goo'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p><h5 id="hasOwnProperty-作为属性"><a href="#hasOwnProperty-作为属性" class="headerlink" title="hasOwnProperty 作为属性"></a>hasOwnProperty 作为属性</h5><p>JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 hasOwnProperty 函数来获取正确的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    hasOwnProperty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: <span class="string">'Here be dragons'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 总是返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</span></span><br><span class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。 同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法， 这将会避免原型对象扩展带来的干扰。</p><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h4><p>和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">moo</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 输出两个属性：bar 和 moo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于不可能改变 for in 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 Object.prototype 原型上的 hasOwnProperty 函数来完成。</p><h5 id="使用-hasOwnProperty-过滤"><a href="#使用-hasOwnProperty-过滤" class="headerlink" title="使用 hasOwnProperty 过滤"></a>使用 hasOwnProperty 过滤</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo 变量是上例中的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (foo.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。 如果不使用 hasOwnProperty，则这段代码在原生对象原型（比如 Object.prototype）被扩展时可能会出错。</p><p>一个广泛使用的类库 Prototype 就扩展了原生的 JavaScript 对象。 因此，当这个类库被包含在页面中时，不使用 hasOwnProperty 过滤的 for in 循环难免会出问题。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>推荐总是使用 hasOwnProperty。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章以一句 ‘回首往事，不因虚度年华而悔恨，也不因碌碌无为而羞耻’ 开头送给自己也送给各位…&lt;/p&gt;
&lt;h3 id=&quot;对象的使用和属性&quot;&gt;&lt;a href=&quot;#对象的使用和属性&quot; class=&quot;headerlink&quot; title=&quot;对象的使用和属性&quot;&gt;&lt;/a&gt;对象的使用和属性&lt;/h3&gt;&lt;p&gt;javascript中所有的变量都可以当成对象来使用，但是有两个除外，null 和 undefined。&lt;br&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AMD，CMD 规范详解</title>
    <link href="https://xiaoyaoge.github.io/AMD-CMD/"/>
    <id>https://xiaoyaoge.github.io/AMD-CMD/</id>
    <published>2017-03-19T19:25:24.000Z</published>
    <updated>2018-10-15T05:46:18.648Z</updated>
    
    <content type="html"><![CDATA[<p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/" target="_blank" rel="noopener">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p><p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p><p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p><p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p><table><thead><tr><th style="text-align:center">服务端JS</th><th style="text-align:center">浏览器端JS</th></tr></thead><tbody><tr><td style="text-align:center">相同的代码需要多次执行</td><td style="text-align:center">代码需要从一个服务器端分发到多个客户端执行</td></tr><tr><td style="text-align:center">CPU 和内存资源是瓶颈</td><td style="text-align:center">宽带是瓶颈</td></tr><tr><td style="text-align:center">加载时从磁盘中加载</td><td style="text-align:center">加载时需要通过网络加载</td></tr></tbody></table><p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p><p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="noopener">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 和 <a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js" target="_blank" rel="noopener">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 在推广过程中对模块定义的规范化产出。</p><p>推荐学习 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>。</p><h2 id="AMD-模块的写法"><a href="#AMD-模块的写法" class="headerlink" title="AMD 模块的写法"></a>AMD 模块的写法</h2><p><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> x+y;</span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　add: add</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>加载方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　myLib.doSomething();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　foo : foo</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p><h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　shim: &#123;</span><br><span class="line">　　<span class="string">'underscore'</span>: &#123;</span><br><span class="line">　　　exports: <span class="string">'_'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　exports: <span class="string">'Backbone'</span></span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line">　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">CMD</a> 是 <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a> 在推广过程中对模块定义的规范化产出。</p><h3 id="CMD-模块定义"><a href="#CMD-模块定义" class="headerlink" title="CMD 模块定义"></a>CMD 模块定义</h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>也可以通过字符串定义模板模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span>);</span><br></pre></td></tr></table></figure></p><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p><h1 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h1><p>区别：</p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们了解了 &lt;a href=&quot;https://neveryu.github.io/2017/03/07/commonjs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CommonJS&lt;/a&gt; 以后，&lt;code&gt;CommonJS&lt;/code&gt; 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。&lt;br&gt;由于 &lt;code&gt;Node.js&lt;/code&gt; 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 &lt;code&gt;CommonJS&lt;/code&gt; 规范比较适用。&lt;br&gt;但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
