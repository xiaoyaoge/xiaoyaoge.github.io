<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小摇歌</title>
  
  <subtitle>个人工作、学习、生活的感悟及所得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaoyaoge.github.io/"/>
  <updated>2018-10-16T04:58:11.885Z</updated>
  <id>https://xiaoyaoge.github.io/</id>
  
  <author>
    <name>Owen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>verify-msg-code 说明文档</title>
    <link href="https://xiaoyaoge.github.io/msgCode/"/>
    <id>https://xiaoyaoge.github.io/msgCode/</id>
    <published>2018-10-16T05:25:56.000Z</published>
    <updated>2018-10-16T04:58:11.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="verify-msg-code"><a href="#verify-msg-code" class="headerlink" title="verify-msg-code"></a>verify-msg-code</h4><p>verify-msg-code 是基于 verify-input-code 插件开发的升级版<br>由于前端一直没时间维护 verify-input-code 所以决定将其废弃<br>verify-msg-code 是基于 Vue2.5+的移动端验证码输入组件.</p><h4 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h4><ul><li>输入时回调</li><li>结果回调</li><li>自定义错误处理</li><li>自定义验证码个数</li><li>样式可控</li><li>输入身份证验证</li><li>可以清空输入的验证码</li></ul><h4 id="基于"><a href="#基于" class="headerlink" title="基于"></a>基于</h4><p>基于 Vue.js 2.5+.</p><h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i verify-msg-code --save</span><br></pre></td></tr></table></figure><ul><li>作为全局组件使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在项目入口文件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VerifyMsgCode <span class="keyword">from</span> <span class="string">'verify-msg-code'</span></span><br><span class="line">Vue.component(<span class="string">'verifyMsgCode'</span>, VerifyMsgCode)</span><br></pre></td></tr></table></figure><ul><li>作为局部组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个组件中</span></span><br><span class="line"><span class="keyword">import</span> VerifyMsgCode <span class="keyword">from</span> <span class="string">'verify-msg-code'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    VerifyMsgCode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>   <a href="https://creativeflower.github.io" target="_blank" rel="noopener">dome地址</a></p><h4 id="插件-API"><a href="#插件-API" class="headerlink" title="插件 API"></a>插件 API</h4><table><thead><tr><th>参数</th><th>类型</th><th>说明</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>code</td><td>数组</td><td>用户输入的验证码数组</td><td>—</td><td>—</td></tr><tr><td>initInput</td><td>函数</td><td>给父组件调用初始化输入框</td><td>—</td><td>-</td></tr><tr><td>type</td><td>字符串</td><td>用户输入类型 当 type 为 idcard 时 number 值为 18</td><td>number,text,idcard</td><td>number</td></tr><tr><td>upper-case</td><td>Boolean</td><td>类型为 text 的时候可调整输入的字符串为大写</td><td>true,false</td><td>false</td></tr><tr><td>get-input</td><td>函数</td><td>用户每次输入后的回调函数,接受一个验证码字符串</td><td>—</td><td>—</td></tr><tr><td>success</td><td>函数</td><td>用户输入完成后的回调函数,接受一个验证码字符串</td><td>—</td><td>—</td></tr><tr><td>error</td><td>函数</td><td>用户输入不是预期的值的回调函数,接收一个错误的值,若返回 true 则不清除错误值并继续下一个输入,默认返回 false</td><td>—</td><td>—</td></tr><tr><td>span-size</td><td>字符串</td><td>输入后的字体显示大小</td><td>—</td><td>20px</td></tr><tr><td>span-color</td><td>字符串</td><td>输入后的字体显示颜色</td><td>—</td><td>#f35252</td></tr><tr><td>input-size</td><td>字符串</td><td>输入框的字体显示大小</td><td>—</td><td>20px</td></tr><tr><td>input-color</td><td>字符串</td><td>输入框的字体显示颜色</td><td>—</td><td>#000</td></tr><tr><td>number</td><td>数字</td><td>验证码个数</td><td>—</td><td>6</td></tr><tr><td>height</td><td>字符串</td><td>整个框的显示高度</td><td>—</td><td>60px</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;verify-msg-code&quot;&gt;&lt;a href=&quot;#verify-msg-code&quot; class=&quot;headerlink&quot; title=&quot;verify-msg-code&quot;&gt;&lt;/a&gt;verify-msg-code&lt;/h4&gt;&lt;p&gt;verify-msg-code 是基
      
    
    </summary>
    
      <category term="vue插件" scheme="https://xiaoyaoge.github.io/categories/vue%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
      <category term="vue插件" scheme="https://xiaoyaoge.github.io/tags/vue%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象</title>
    <link href="https://xiaoyaoge.github.io/object/"/>
    <id>https://xiaoyaoge.github.io/object/</id>
    <published>2018-10-15T05:25:24.000Z</published>
    <updated>2018-10-15T08:21:21.796Z</updated>
    
    <content type="html"><![CDATA[<p>文章以一句 ‘回首往事，不因虚度年华而悔恨，也不因碌碌无为而羞耻’ 开头送给自己也送给各位…</p><h3 id="对象的使用和属性"><a href="#对象的使用和属性" class="headerlink" title="对象的使用和属性"></a>对象的使用和属性</h3><p>javascript中所有的变量都可以当成对象来使用，但是有两个除外，null 和 undefined。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>.toString(); <span class="comment">// 'false'</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString(); <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="string">'123'</span>.length; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Foo.bar = <span class="number">1</span>;</span><br><span class="line">Foo.bar; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>大家常常误解数字的字面值（literal）不能当做是对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString(); <span class="comment">// 出错：SyntaxError</span></span><br></pre></td></tr></table></figure><p>其实有很多的方法可以让数字的字面量看起来像对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// "2" 第二个点号可以解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// "2"  点前面有个空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// "2" 括号中的的数字会被先计算</span></span><br><span class="line">(<span class="number">2</span>+<span class="number">1</span>).toString(); <span class="comment">// "3" 括号中的的数字会被先计算</span></span><br></pre></td></tr></table></figure></p><h5 id="对象作为数据类型"><a href="#对象作为数据类型" class="headerlink" title="对象作为数据类型"></a>对象作为数据类型</h5><p>JavaScript的对象可以作为<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表</a>使用,只要是用来保存命名的键与值的对应关系。</p><p>使用对象的字面语法 - {} - 可以创建一个简单的对象。这个新建的对象从Object.prototype 继承下面，没有任何自定义属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = &#123;&#125; <span class="comment">// 空对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cat = &#123; <span class="attr">name</span>:<span class="string">'小黑'</span>&#125; <span class="comment">// 一个新对象 拥有一个值为小黑的自定义属性 'name'</span></span><br></pre></td></tr></table></figure></p><h5 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h5><p>javascrippt 对象有两种方式来访问属性，点操作符和中括号操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = &#123; <span class="attr">name</span>: <span class="string">'小黑'</span>&#125;</span><br><span class="line">Dog.name <span class="comment">// 小黑</span></span><br><span class="line">Dog[<span class="string">'name'</span>] <span class="comment">// 小黑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="string">'name'</span></span><br><span class="line">Dog[getName] <span class="comment">// 小黑</span></span><br><span class="line">Dog<span class="number">.123</span> <span class="comment">//  会 SyntaxError</span></span><br><span class="line">Dog[<span class="string">'1234'</span>] <span class="comment">// 可以正常执行</span></span><br></pre></td></tr></table></figure></p><p>这两种语法是等价的，但是中括号操作符在下面两种情况下依然有效<br>1.动态设置属性<br>2.属性名不是一个有效的变量名。（注意点：比如属性名中包含空格，或者属性名是 JS 的关键词 在 JSLint 语法检测工具中，点操作符是推荐做法）</p><h5 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h5><p>删除属性唯一的方法是使用 delete 操作符，将对象属性设置为undefined或者null都不能真正删除属性，而仅仅是移除了属性和值的关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">bor: <span class="number">1</span>,</span><br><span class="line">foo: <span class="number">2</span>,</span><br><span class="line">baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.bor = <span class="literal">undefined</span>;</span><br><span class="line">obj.foo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.baz</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj )&#123;</span><br><span class="line"><span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i, <span class="string">' --&gt; '</span> + obj[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出的结果</span></span><br><span class="line">bor --&gt; <span class="literal">undefined</span></span><br><span class="line">foo --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><p>从上面输出的结果看，只有 baz 被真正的删除，所以就没有出现在输出结果中</p><h5 id="属性名的语法"><a href="#属性名的语法" class="headerlink" title="属性名的语法"></a>属性名的语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"><span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span></span><br><span class="line"><span class="keyword">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的属性名可以使用字符串或普通字符声明。但是由于JavaScript解释器的另一个错误设计，上面的的第二种声明方式在ECMAScript5 之前会抛出 SyntaxError 的错误<br>这个错误的原因是 delete 是 JavaScript 语言的一个关键词；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用字符串字面值声明方式。</p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>JavaScript不包含传统的类继承模型，而是使用porttype原型模型。<br>虽然这经常被当做是JavaScript的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大，实现传统的类继承模很简单，但是实现JavaScript中的原型继承则要困难的多 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p><p>传统类继承和JavaScript原型继承的差异</p><p>第一个不同这出在于 JavaScript使用的是原型链的继承方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Bar的prototype属性为Foo的实例对象</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line">Bar.prototype.foo = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正Bar.prototype.constructor为Bar本身</span></span><br><span class="line">Bar.prototype.constructor = Bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Bar() <span class="comment">// 创建Bar的一个新实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">test [Bar的实例]</span><br><span class="line">    Bar.prototype [Foo的实例] </span><br><span class="line">        &#123; <span class="attr">foo</span>: <span class="string">'Hello World'</span> &#125;</span><br><span class="line">        Foo.prototype</span><br><span class="line">            &#123;<span class="attr">method</span>: ...&#125;;</span><br><span class="line">            <span class="built_in">Object</span>.prototype</span><br><span class="line">                &#123;<span class="attr">toString</span>: ... <span class="comment">/* etc. */</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的例子中，test 对象从 Bar.prototype 和Foo。prototype 继承下来；因此，它能访问 Foo 的原型方法 method。同时，他也能够访问那个定义在原型上的 Foo 实例属性 value。 需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是重复使用它原型上的那个实例； 因此，所有的 Bar 实例都会共享相同的 value 属性。<br>注意: 简单的使用 Bar.prototype = Foo.prototype 将会导致两个对象共享相同的原型。 因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p><h5 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h5><p>当查找一个对象的属性是，JavaScript 会向上遍历原型链，知道找到给定名称的属性为止。</p><p>到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定属性，就会返回 undefined</p><h5 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h5><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="number">1</span>; <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure></p><p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p><p>并且，当使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问。</p><h5 id="扩展内置类型的原型"><a href="#扩展内置类型的原型" class="headerlink" title="扩展内置类型的原型"></a>扩展内置类型的原型</h5><p>一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。</p><p>这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。</p><p>扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如 Array.forEach。</p><p>注意：这是编程领域常用的一种方式，称之为 Backport，也就是将新的补丁添加到老版本中。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p><h4 id="hasOwnProperty-函数"><a href="#hasOwnProperty-函数" class="headerlink" title="hasOwnProperty 函数"></a>hasOwnProperty 函数</h4><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 Object.prototype 的 hasOwnProperty 方法。</p><p>注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 undefined。</p><p>hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">goo</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar; <span class="comment">// 1</span></span><br><span class="line"><span class="string">'bar'</span> <span class="keyword">in</span> foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// false</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'goo'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p><h5 id="hasOwnProperty-作为属性"><a href="#hasOwnProperty-作为属性" class="headerlink" title="hasOwnProperty 作为属性"></a>hasOwnProperty 作为属性</h5><p>JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 hasOwnProperty 函数来获取正确的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    hasOwnProperty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: <span class="string">'Here be dragons'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 总是返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</span></span><br><span class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。 同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法， 这将会避免原型对象扩展带来的干扰。</p><h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h4><p>和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">moo</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 输出两个属性：bar 和 moo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于不可能改变 for in 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 Object.prototype 原型上的 hasOwnProperty 函数来完成。</p><h5 id="使用-hasOwnProperty-过滤"><a href="#使用-hasOwnProperty-过滤" class="headerlink" title="使用 hasOwnProperty 过滤"></a>使用 hasOwnProperty 过滤</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo 变量是上例中的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (foo.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。 如果不使用 hasOwnProperty，则这段代码在原生对象原型（比如 Object.prototype）被扩展时可能会出错。</p><p>一个广泛使用的类库 Prototype 就扩展了原生的 JavaScript 对象。 因此，当这个类库被包含在页面中时，不使用 hasOwnProperty 过滤的 for in 循环难免会出问题。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>推荐总是使用 hasOwnProperty。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章以一句 ‘回首往事，不因虚度年华而悔恨，也不因碌碌无为而羞耻’ 开头送给自己也送给各位…&lt;/p&gt;
&lt;h3 id=&quot;对象的使用和属性&quot;&gt;&lt;a href=&quot;#对象的使用和属性&quot; class=&quot;headerlink&quot; title=&quot;对象的使用和属性&quot;&gt;&lt;/a&gt;对象的使用和属性&lt;/h3&gt;&lt;p&gt;javascript中所有的变量都可以当成对象来使用，但是有两个除外，null 和 undefined。&lt;br&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AMD，CMD 规范详解</title>
    <link href="https://xiaoyaoge.github.io/AMD-CMD/"/>
    <id>https://xiaoyaoge.github.io/AMD-CMD/</id>
    <published>2017-03-19T19:25:24.000Z</published>
    <updated>2018-10-15T05:46:18.648Z</updated>
    
    <content type="html"><![CDATA[<p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/" target="_blank" rel="noopener">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p><p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p><p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p><p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p><table><thead><tr><th style="text-align:center">服务端JS</th><th style="text-align:center">浏览器端JS</th></tr></thead><tbody><tr><td style="text-align:center">相同的代码需要多次执行</td><td style="text-align:center">代码需要从一个服务器端分发到多个客户端执行</td></tr><tr><td style="text-align:center">CPU 和内存资源是瓶颈</td><td style="text-align:center">宽带是瓶颈</td></tr><tr><td style="text-align:center">加载时从磁盘中加载</td><td style="text-align:center">加载时需要通过网络加载</td></tr></tbody></table><p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p><p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="noopener">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 和 <a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js" target="_blank" rel="noopener">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 在推广过程中对模块定义的规范化产出。</p><p>推荐学习 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>。</p><h2 id="AMD-模块的写法"><a href="#AMD-模块的写法" class="headerlink" title="AMD 模块的写法"></a>AMD 模块的写法</h2><p><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> x+y;</span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　add: add</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>加载方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　myLib.doSomething();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　foo : foo</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p><h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　shim: &#123;</span><br><span class="line">　　<span class="string">'underscore'</span>: &#123;</span><br><span class="line">　　　exports: <span class="string">'_'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　exports: <span class="string">'Backbone'</span></span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line">　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">CMD</a> 是 <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a> 在推广过程中对模块定义的规范化产出。</p><h3 id="CMD-模块定义"><a href="#CMD-模块定义" class="headerlink" title="CMD 模块定义"></a>CMD 模块定义</h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>也可以通过字符串定义模板模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span>);</span><br></pre></td></tr></table></figure></p><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p><h1 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h1><p>区别：</p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们了解了 &lt;a href=&quot;https://neveryu.github.io/2017/03/07/commonjs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CommonJS&lt;/a&gt; 以后，&lt;code&gt;CommonJS&lt;/code&gt; 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。&lt;br&gt;由于 &lt;code&gt;Node.js&lt;/code&gt; 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 &lt;code&gt;CommonJS&lt;/code&gt; 规范比较适用。&lt;br&gt;但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://xiaoyaoge.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://xiaoyaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
